Директива  "use  strict"  переключает движок в «современный» режим, изменяя поведение некоторых встроенных функций. Позже в учебнике мы увидим подробности.
___

Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript. Обратные кавычки же имеют «расширенный функционал». Они позволяют нам встраивать выражения в строку, заключая их в  `${…}`.
___

Обычно  `null`  используется для присвоения переменной «пустого» или «неизвестного» значения, а  `undefined`  – для проверок, была ли переменная назначена.

___
Вызов eval(code) выполняет строку кода и возвращает результат последней инструкции.
___
Каррирование – это трансформация, которая превращает вызов f(a, b, c) в f(a)(b)(c). В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.
___

Intl: интернационализация в JavaScript (правильное сравнение строк, интерпретация дат и чисел)
___

***В JavaScript есть 7 основных типов.***

* number  для любых чисел: целочисленных или чисел с плавающей точкой.
* string  для строк. Строка может содержать один или больше символов, нет отдельного символьного типа.
* boolean для true/false.
* null  для неизвестных значений – отдельный тип, имеющий одно значение  null.
* undefined  для неприсвоенных значений – отдельный тип, имеющий одно значение  undefined.
* object  для более сложных структур данных.
* symbol для уникальных идентификаторов.
---

Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
Для  null  возвращается  "object"  – это ошибка в языке, на самом деле это не объект.

|Значение|Преобразуется в|
|---|--|
| undefined | NaN |
| null     |   0 |
| true / false | 1 / 0|
|string|Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то  0, иначе из непустой строки «считывается» число. При ошибке результат NaN.|
___
| Значение | Становится |
|---|--|
| 0, null, undefined, NaN, ""| false|
|любое другое значение | true |
___


### Функции
* имя функции нам доступно как свойство «name»
* свойство «length» содержит количество параметров функции в её объявлении

*Синтаксис "new Function"*
```javascript
let sum = new Function('a', 'b', 'return a + b'); // стандартный синтаксис
sum = new Function('a,b', 'return a + b'); // через запятую в одной строке
sum = new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
alert( sum(1, 2) ); // 3
```
Если функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным. Если бы new Function имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.

***Function Declaration_***
```javascript
function  sayHi()  {
	alert(  "Привет"  );
}
```

 Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке). В строгом режиме, когда Function Declaration находится в блоке  `{...}`, функция доступна везде внутри блока.Но не снаружи него.

***Function Expression***
```javascript
let  sayHi  =  function()  {
	alert(  "Привет"  );
	};
```
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
Функции-стрелки могут быть использованы так же, как и Function  Expression.

***Стрелочные функции***
Предназначены для небольшого кода, который не имеет своего «контекста», выполняясь в текущем
- У стрелочных функций нет «this»
- Стрелочные функции не имеют «arguments»
- Не могут быть вызваны с new.
- У них также нет super
___

**Mocha** -  основной фреймворк. Он предоставляет общие функции тестирования, такие как  describe  и  it, а также функцию запуска тестов.

```javascript
describe("pow", function() {
  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} в степени 3 будет ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }
  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }
});
```
___
### Вычисляемые свойства

```javascript
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
```

### Array
Чтобы пройтись по элементам массива:

* for (let i=0; i< arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
* for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
* for (let i in arr) – никогда не используйте для массивов!

Деструктуризация массива:
```javascript
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
alert( title ); // Consul
```

### Simbol
Свойства, чьи ключи – символы, не перебираются циклом for..in.
Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы.

Символы имеют два основных варианта использования:
- «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. 

- Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

___

### THIS
```javascript
let user = {
  name: "Джон",
  hi() { alert(this.name); },
  bye() { alert("Пока"); }
};
user.hi(); // Джон (простой вызов метода работает хорошо)
// теперь давайте попробуем вызывать user.hi или user.bye
// в зависимости от имени пользователя user.name
(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
```
Присмотревшись поближе, в выражении obj.method() можно заметить две операции:

1. Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
2. Затем скобки () вызывают этот метод (исполняется код метода).

Значение this определяется во время исполнения кода.

* При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
* Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является объект перед точкой.

Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.

### NEW 
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

* Имя функции-конструктора должно начинаться с большой буквы.
* Функция-конструктор должна вызываться при помощи оператора "new".

Когда функция вызывается как new User(...), происходит следующее:

1. Создаётся новый пустой объект, и он присваивается this.
2. Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
3. Возвращается значение this.

Но если return из конструктора всё же есть, то применяется простое правило:

- При вызове return с объектом, будет возвращён объект, а не this.
- При вызове return с примитивным значением, примитивное значение будет отброшено.

### VAR

Для var не существует блочной области видимости. Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).
```javascript
function sayHi() {
  phrase = "Привет";
  alert(phrase);
  var phrase;
}
sayHi();
```
```javascript
function sayHi() {
  var phrase;

  phrase = "Привет";

  alert(phrase);
}
sayHi();
```
Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции. Объявления переменных «всплывают», но присваивания значений – нет.
____

### Замыкание
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В  JavaScript, все функции изначально являются замыканиями, автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и могут получить доступ к внешним переменным.

### IIFE (immediately-invoked function expressions)
```javascript
// Пути создания IIFE
(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с побитового оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();
```
___

### Планирование: setTimeout and setInterval
* setTimeout позволяет вызвать функцию один раз через определённый интервал времени. (Отмена через clearTimeout)
* setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

###  сall/apply/bind

func.call(context, arg1, arg2, ...)
func.apply(context, args)
func.bind(context, [arg1], [arg2], ...);

Частичное применение без контекста
```javascript
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}
```
___

### Прототипное наследование

- В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип».
- Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]].
- Современные же методы это:

    * Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
    * Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
    * Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.

- Прототипы никак не влияют на this. Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.
- Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта. Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).

Ещё методы:

-   [Object.keys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)  /  [Object.values(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values)  /  [Object.entries(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)  – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
-   [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)  – возвращает массив всех собственных символьных ключей.
-   [Object.getOwnPropertyNames(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)  – возвращает массив всех собственных строковых ключей.
-   [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)  – возвращает массив всех собственных ключей.
-   [obj.hasOwnProperty(key)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty): возвращает  `true`, если у  `obj`  есть собственное (не унаследованное) свойство с именем  `key`.

***F.prototype***
```javascript
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;
let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal
alert( rabbit.eats ); // true
```
Установка  `Rabbit.prototype = animal`  буквально говорит интерпретатору следующее: "При создании объекта через  `new Rabbit()`  запиши ему  `animal`  в  `[[Prototype]]`".

* Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().
* Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
* Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.

### Встроенные прототипы
obj = {} – это то же самое, что и obj = new Object(), где Object – встроенная функция-конструктор для объектов с собственным свойством prototype, которое ссылается на огромный Object.prototype с методом toString и другими
* Все встроенные объекты следуют одному шаблону:
    - Методы хранятся в прототипах (Array.prototype, Object.prototype, Date.prototype и т.д.).
    - Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).
* Примитивы также хранят свои методы в прототипах объектов-обёрток: Number.prototype, String.prototype, Boolean.prototype. Только у значений undefined и null нет объектов-обёрток.

```javascript
let obj = {};
alert(obj.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString == Object.prototype.toString
```
___

### Класс
```javascript
class MyClass {
  prop = value; 
  constructor(...) { 
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}
```

Вот что на самом деле делает конструкция class User {...}:

* Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
* Сохраняет все методы, такие как sayHi, в User.prototype.
* При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.

Отличие от реализации с помощью функции:
* Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[FunctionKind]]:"classConstructor". Поэтому это не совсем то же самое, что создавать её вручную.
* Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
* Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

У классов есть ключевое слово "super" для таких случаев.

* super.method(...) вызывает родительский метод.
* super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).

Когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]] становится равно этому объекту. Единственное место в языке, где используется [[HomeObject]] – это super. Поэтому если метод не использует super, то мы все ещё можем считать его свободным и копировать между объектами. А вот если super в коде есть, то возможны побочные эффекты.Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса. (Еще не введено)

***Проверка класса***
|| работает для | возвращает |
|---|---|---|
|`typeof` | примитивов | строка|
| `{}.toString`| примитивов, встроенных объектов, объектов с  `Symbol.toStringTag`| строка
|`instanceof` | объектов| true/false

### Примеси
 Примесь – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.

 Пример примеси:
```javascript
// примесь
let sayHiMixin = {
  sayHi() {
    alert(`Привет, ${this.name}`);
  },
  sayBye() {
    alert(`Пока, ${this.name}`);
  }
};
// использование:
class User {
  constructor(name) {
    this.name = name;
  }
}
// копируем методы
Object.assign(User.prototype, sayHiMixin);
// теперь User может сказать Привет
new User("Вася").sayHi(); // Привет, Вася!
```

***EventMixin***
1. .on(eventName, handler) – назначает функцию handler, чтобы обработать событие с заданным именем. Обработчики хранятся в свойстве _eventHandlers, представляющим собой объект, в котором имя события является ключом, а массив обработчиков – значением.

2. .off(eventName, handler) – убирает функцию из списка обработчиков.

3. .trigger(eventName, ...args) – генерирует событие: все назначенные обработчики из _eventHandlers[eventName] вызываются, и ...args передаются им в качестве аргументов.

___

### Промисы
Promise  – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе.
```javascript
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
  });
}

let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} загружен!`),
  error => alert(`Ошибка: ${error.message}`)
);

promise.then(script => alert('Ещё один обработчик...'));
```

Функция будет создавать и возвращать объект Promise, который будет переходить в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя .then

| Промисы| Колбэки|
|---|---
|Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем  `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом.|У нас должна быть функция`callback`  на момент вызова  `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом  _до того_, как вызовется  `loadScript`.
|Мы можем вызывать  `.then`  у  `Promise`  столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок».| Колбэк может быть только один.

Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач

- then (Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.)
- catch (это сокращённый, «укороченный» вариант .then(null, f), перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.)
- finally(f) ( .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.)

**Статические методы класса Promise**

* Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
* Promise.allSettled(promises) (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
    - state: "fulfilled", если выполнен успешно или "rejected", если ошибка,
    - value – результат, если успешно или reason – ошибка, если нет.
* Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
* Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
* Promise.reject(error) – возвращает промис с ошибкой error

### Async/await

- У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.
- Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.

### Генераторы

Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением. Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат наружу, но и может передавать значение извне в генератор. Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.
```javascript
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, затем 2, затем 3
}
```
Результатом метода next() всегда является объект с двумя свойствами:
- value: значение из yield.
- done: true, если выполнение функции завершено, иначе false.
```javascript
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {
  // 0..9
  yield* generateSequence(48, 57);
  // A..Z
  yield* generateSequence(65, 90);
  // a..z
  yield* generateSequence(97, 122);
}
```
Когда мы ожидаем, что данные будут поступать асинхронно, с задержками, можно использовать их асинхронные аналоги и for await..of вместоfor..of.

Синтаксические различия между асинхронными и обычными итераторами:

| |Перебираемый объект|	Асинхронно перебираемый|
|---|---|---|
| Метод для получения итератора| 	Symbol.iterator	|Symbol.asyncIterator| 
| next() возвращает|	{value:…, done: true/false}|	промис, который завершается с {value:…, done: true/false}
Синтаксические различия между асинхронными и обычными генераторами:

||Генераторы	|Асинхронные генераторы|
|---|---|---|
|Объявление|	function*	|async function*|
|generator.next() возвращает|	{value:…, done: true/false}	|промис, который завершается с {value:…, done: true/false}|

### Модули

1. Модуль – это файл. Чтобы работал import/export, нужно для браузеров указывать атрибут ``` <script type="module">```. У модулей есть ряд особенностей:
- Отложенное (deferred) выполнение по умолчанию.
- Атрибут async работает во встроенных скриптах.
- Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.
- Дублирующиеся внешние скрипты игнорируются.
2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.
3. В модулях всегда включена директива use strict.
4. Код в модулях выполняется только один раз. Экспортируемая функциональность создётся один раз и передаётся всем импортёрам.

### ES6feature
- const and let
- Template Strings \`Template Strings\`
- Arrow Functions
- Default argument
- Import and export
- class
- Promises

## JEST
File name : `temp.test.js`

``` javascript
test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});

test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
```

- toBeNull 
- toBeUndefined
- toBeDefined 
- toBeTruthy 
- toBeGreaterThan
- toBeGreaterThanOrEqual
- toBeLessThan
- toBeLessThanOrEqual
- toBe
- toEqual
- toBeCloseTo
- toThrow
- toMatch
- toContain

## Enzyme

Для тестирования React
``` javascript 
describe('<MyComponent />', () => {
  it('renders an `.icon-star`', () => {
    const wrapper = shallow(<MyComponent />);
    expect(wrapper.find('.icon-star')).to.have.lengthOf(1);
  });
  
  it('renders three <Foo /> components', () => {
    const wrapper = shallow(<MyComponent />);
    expect(wrapper.find(Foo)).to.have.lengthOf(3);
  });

  it('allows us to set props', () => {
    const wrapper = mount(<Foo bar="baz" />);
    expect(wrapper.props().bar).to.equal('baz');
    wrapper.setProps({ bar: 'foo' });
    expect(wrapper.props().bar).to.equal('foo');
  });

  it('renders the title', () => {
    const wrapper = render(<Foo title="unique" />);
    expect(wrapper.text()).to.contain('unique');
  });
});
```
